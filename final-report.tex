%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page LaTeX Template Version 1.0 (27/12/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
%
% Original author: WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template: This title page is capable of being compiled as is. This is not useful for
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} starting at \begin{titlepage} and paste this into
% another LaTeX file where you want your title page.  OR 2) Remove everything outside the \begin{titlepage} and
% \end{titlepage} and move this file to the same directory as the LaTeX file you wish to add it to.  Then add
% \input{./title_page_1.tex} to your LaTeX file where you want your title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo} ----------------------------------------------------------------------------------------
%PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
% HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Nanyang Technological University}\\[1.5cm] % Name of your university/college
\textsc{\Large School of Computer Engineering}\\[0.5cm] % Major heading such as course name
\textsc{\large Final Year Project}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm] { \huge \bfseries Final Report}\\[0.4cm] % Title of your document \HRule \\[1.5cm]
 
%---------------------------------------------------------------------------------------- AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
    \begin{flushleft}
        \large \emph{Author:}\\ Tuan Phong
        \textsc{Nguyen} % Your name
    \end{flushleft}
\end{minipage} ~
\begin{minipage}{0.4\textwidth}
    \begin{flushright}
        \large \emph{Supervisor:} \\ Assoc Prof Chiew Tong
        \textsc{Lau} % Supervisor's Name \end{flushright} \end{minipage}\\[2cm]
    \end{flushright}
\end{minipage}

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\ John \textsc{Smith}\\[3cm] % Your name

%---------------------------------------------------------------------------------------- DATE SECTION
    %----------------------------------------------------------------------------------------

{\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

%---------------------------------------------------------------------------------------- LOGO SECTION
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\linespread{1.25}
\section{Introduction}
Along with the development of more compact and portable platform for measuring health related data, there are many
products on the market that are capable of reading and sending data to a computer system. These devices are often built
ready for communicating with mobile devices via Bluetooth to exchange data so that those data can be displayed visually.
However, a universal platform to collect and display the data to users has not been implemented yet. On the other hand,
the measured data is not frequently recorded so that it can be used as reference in diagnosing or study.  This project
aims to implement such a platform with consideration on capability of adapting multiple types of devices, data sharing
as well as the scalability.

\section{Literature review}
With the development of technology and medical system, there are several studies to create a system to monitor
patients's condition in realtime effectively and correctly to enable proactive monitoring \cite{5076774}, with the help
of embedded computer system \cite{4062461}. Furthermore, devices with communication capabilities have been developed to
measure human body's reading for long-range mdecial healthcare system and avoid the cost of nursing expense in families
\cite{5918041}. On the other hand, the system which provide a common interface for large number of users must be able to
serve great amount of traffics and interactions with the clients.  In order to handle large volume of simulatenous
interaction to the database, an efficient and scalable approach must be used for database handling instead of
traditional server. A highly available and reliable distributed platform is provided by Google Datastore, which offers
many possibilities in developing such a system to store the data on the cloud \cite{7059154}.

\section{Architecture design}
\label{sec:Architecture design}
The application contains 3 main components namely the client, the backend server and the database.

\subsection{Client side}
The client is responsible for displaying the data acquired from the physical measuring devices visually as graph or
reading listing. The client application needs to acquire the the data records from the backend server through network
communication and cache it in local database for presenting to the app user. In order to server as a universal interface to
various types of medical record, the interface is capable of displaying different types of graph for different record
type and designed to be extended when there is need for a new representation of data. The client connects 
to the back-end to interact with other users of the application to share and access their data in the database. The
client also provides the user with an interface to search for another users of the application and interact with them.
Users can subscribe to another user to view their data and receive notifications upon certain events are triggered such
as when new data is uploaded or when the reading is beyond safe range. As the database is accessed through a RESTful API
via HTTP request and response, the client application can be implemented in any platform e.g. Android, iOS, native
desktop program or web application. Due to time constraint and man power of this project as well as the extensibility to
other projects, the client is only implemented for android phones.

\subsection{Server side}
The server is a Web server that exposes a RESTful API to the clients and serves the incoming requests. To perform the
business logic, the server interacts with a persistent database to provide the service as application backend. To
elevate scalability of the application, the server side is chosen to be hosted on Google App Engine cloud service. By
using cloud computing from a credible service provider, the application aims to minimize down-time and bottleneck
comparing to self-hosting service on a single computer.  In addition, hosting application on a cloud platform also
enables the application cost to scale better with the number of users and data traffic since the service provider offers
multiple pricing tiers for different amount of traffic.  Moreover, Datastore database provided by Google also supports
caching and reliably distributes data to different locations with minimal latency.  Regarding implementation of ther
server program, since client and server communicate through a RESTful API, the server can also be implemented in any
programming languages. In this project, the web server is implemented in Java with Google Endpoints API
\cite{CloudEndpoints} with Cloud Search API \cite{SearchAPI}.  This approach helps promote code reuse by sharing Java
object between client and server codebase. In the future, the server can be swapped out by any web server if there is
need for finer control or performance improvement.

\subsection{Database}
Google Cloud Datastore is chosen to be the database backend of the system to reliably store and deliver data. Google
Cloud Datastore is a schema-less NoSQL Datastore providing robust, reliable storage for the web application. In
constrast with SQL-like database, Datastore treats each record in the database as a key-value pair without unnecessary
indexes. Comparing to the traditional relation databases, the Datastore uses a distributed architecture to automatically
managing scaling to very large data sets. Additionally, Datastore is hosted as part of the Google App Engine platform,
hence is fully managed with no planned down time by Google. Due to its different way of representing and managing data,
the Datastore can be easily scaled, allowing the application to maintain high performance as the traffic is increased.

\section{Implementation}
\subsection{Google Cloud Datastore}
\subsubsection{DataRecord}
The \texttt{DataRecord} class is used to contain the information of a user's reading values uploaded from the client
application or hardware. The model contains various properties about the data record including the type e.g. Simple,
Blood Pressure data, created date and the reading value represented by a String. The representation of a reading depends
on the type of interested measurement, hence the Datastore Entity does not enforce any constraint on the String format
and relies on the client and server application to correctly serialize and deserialize the value from and to the correct
string. \texttt{DataRecord} has the child - parent relationship with a user entity that supports efficient querying of
all instances that belong to a given user. Lastly, the type attribute is marked to be indexed by Datastore engine so as
to the server can query on specific type of data of interest.
\begin{minipage}{\linewidth}
\lstset{language=java,caption={DataRecord properties},label=DataRecord properties}
\begin{lstlisting}
@Entity
public class DataRecord {
    @Id public Long id;
    @Parent private Ref<HealthDroidUser> user;
    private Date date;
    @Index private int type;
    private Date createdAt;
    private String value;
}
\end{lstlisting}
\end{minipage}

\subsubsection{HealthDroidUser}
The \texttt{HealthDroidUser} class is used to represent a user of the application separately from their Google account.
The \texttt{HealthDroidUser} instance is created when the user logs into the system for the first time and will be used
as the reference for all their relevant data. The user object will not be created again on the next time the user logs
in.

\subsubsection{RegistrationRecord}
The \texttt{RegistrationRecord} class is used to represent a device that logged into the application and ready to receive
pushed message via Google Cloud Messaging.  The \texttt{RegistrationRecord} instance is created when a device logs into the
system and removed from Datastore database if it fails to send the message to the device i.e. the device is no longer
used or signed in with another user.

\subsubsection{SubscriptionRecord}
The \texttt{SubscriptionRecord} class is used to represent a subscription relationship between a user (subscriber) and
another user (target) and create a many-to-many relationship among users. The \texttt{SubscriptionRecord} is created
upon receiving a request to subscribe from the client application and deleted upon receiving a request to unsubscribe.
Since such a request need to be approved by the subscribed party, the \texttt{SubscriptionRecord} contains a
\texttt{isAccepted} value to indicate the status, which is false by default and only set to true once the user accepts
that. \texttt{SubscriptionRecord} has a child-parent relationship with the target user, and a reference to the
subscriber. Thus, the instances can be queried when finding users who subscribed to a given users or users subscribed to
by a given user.

\begin{minipage}{\linewidth}
\lstset{
    frame=tb,
    caption={SubscriptionRecord},
    label=SubscriptionRecord
    language=Java,
    aboveskip=\baselineskip,
    belowskip=\baselineskip,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}
\begin{lstlisting}SubscriptionRecord
@Entity
public class SubscriptionRecord {
    @Id Long id;
    @Index private Boolean isAccepted;
    @Index private transient Ref<HealthDroidUser> subscriber;
    @Parent private transient Ref<HealthDroidUser> target;
}
\end{lstlisting}
\end{minipage}

\subsection{Server side}
The application server is implemented with Google Cloud Endpoints API in Java. The server can be accessed through a
RESTful API via HTTP requests and responses. In this project, several models of the application can be interacted with
through separate classes called an endpoint, each represent a feature and relevant methods. Each endpoint consists of
one or more methods annotated with \texttt{@ApiMethod} annotation and is exposed to outside accesses.

\subsubsection{Data}
\texttt{Data API} is contained in \texttt{DataEndpoint}. The Data API contains the following methods \\
\begin{minipage}{\linewidth}
\lstset{
    frame=tb,
    caption={Data API},
    label=Data API
    language=Java,
    aboveskip=\baselineskip,
    belowskip=\baselineskip,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}
\begin{lstlisting}
@ApiMethod(name = "add")
public DataRecord addData(@Named("value") String value, @Named("date") Date date, @Named("type") int type, User user)
@ApiMethod(name = "get");
public List<DataRecord> getDataRecord(@Nullable @Named("userId") String userId, @Nullable @Named("after") Date after)
\end{lstlisting}
\end{minipage}

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline addData() & 
            this method is used to add a data entry to datastore. The method is only allowed to be access by
            authenticated user as required in user parameter \\
        \hline getDataRecord() &
            this method is used to get the data from datastore. The method takes 2 optional aruguments namely userId, to
            specify the user which data entries belong to and after, to set a lower limit of date in data entries. The
            "after" argument can be used to efficiently get only the new data entries in datastore for update operation
            \\
        \hline
    \end{tabular}
    \caption{Data API methods description}
\end{center}
\end{table}

\subsubsection{User}
User API provides methods to interact with the user model of the applicaton.
\begin{minipage}{\linewidth}
\lstset{
    frame=tb,
    caption={User API},
    label=User API
    language=Java,
    aboveskip=\baselineskip,
    belowskip=\baselineskip,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}
\begin{lstlisting}
@ApiMethod(name = "add")
public HealthDroidUser addUser(User user)

@ApiMethod(name = "get")
public List<HealthDroidUser> getUser(@Nullable @Named("userId") String userId)

@ApiMethod(name = "query")
public List<HealthDroidUser> queryUser(@Named("queryString") String queryString)
\end{lstlisting}
\end{minipage}

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline addUser() & 
            this method is used to add a user to datastore. The method is only allowed to be access by
            authenticated user as required in user parameter. Upon user signing in, the method is called and user is
            created if not already existing in the database. The method is idempotent and being called multiple times
            does not recreate the user. In addition, the method also create an entry used by Google Search API to
            support searching with Google's API.  \\
        \hline getUser() &
            this method is used to get the user from datastore. The method takes a userId as String and return
            information about the data from the database \\
        \hline queryUser() &
            this method is used to query a list of users from part of the user ID. Since Datastore does not index all
            attributes by default and hence not allow to straight forward search for user ID string. To support the
            query for large number of users in the database, the method use Google Search API. \\
        \hline
    \end{tabular}
    \caption{User API}
\end{center}
\end{table}

\subsubsection{Registration}
\begin{minipage}{\linewidth}
\lstset{
    frame=tb,
    caption={Registration API},
    label=Registration API
    language=Java,
    aboveskip=\baselineskip,
    belowskip=\baselineskip,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}
\begin{lstlisting}
@ApiMethod(name = "register")
public void registerDevice(@Named("regId") String regId, User user)

@ApiMethod(name = "unregister")
public void unregisterDevice(@Named("regId") String regId)

@ApiMethod(name = "listDevices")
public CollectionResponse<RegistrationRecord> listDevices(@Named("count") int count)
\end{lstlisting}
\end{minipage}

Registration API provides the methods to register and unregister a device to the backend system for receiving
notifications via Google Cloud Messaging.

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline registerDevice() & 
            this method is used to register a device to the backend. The method is only allowed to be accessed by an
            authenticated user and create a \texttt{RegistrationRecord} entity. \\
        \hline unregisterDevice() &
            this method is used to unregister a device to the backend.\\
        \hline listDevices() &
            this method is used to query a list of all device registrations that belong to a user. \\
        \hline
    \end{tabular}
    \caption{User API}
\end{center}
\end{table}

\subsubsection{Subscription}
Subscription API provides the methods to interact with subscriptions between users in the datastore. \\
\begin{minipage}{\linewidth}
\lstset{
    frame=tb,
    caption={Subscription API},
    label=Subscription API
    language=Java,
    aboveskip=\baselineskip,
    belowskip=\baselineskip,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}
\begin{lstlisting}
@ApiMethod(name = "subscribe")
public SubscriptionRecord subscribe(@Named("target") String target, User user)

@ApiMethod(name = "accept")
public SubscriptionRecord acceptSubscription(@Named("subscriptionId") Long subscriptionId, User user)

@ApiMethod(name = "list")
public List<SubscriptionRecord> listSubscriptions()

@ApiMethod(name = "subscribed")
public Collection<SubscriptionRecord> getSubscribed(User user)

@ApiMethod(name = "subscribers")
public Collection<SubscriptionRecord> subscribers(@Named("userId") String userId) 

@ApiMethod(name = "pending")
public Collection<SubscriptionRecord> pending(@Named("userId") String userId)

@ApiMethod(name = "unsubscribe")
public List<SubscriptionRecord> unsubscribe(@Named("userId") String userId, @Nullable @Named("target") String target)
\end{lstlisting}
\end{minipage}

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline listSubscription() & 
            this method is used to list all the subscription records in the database. \\
        \hline getSubscribed() & 
            this method is used to get all the users that is subscribed to by a give user. \\
        \hline subsribers() & 
            this method is used to get all the users that subscribed to a given user. \\
        \hline subscribe() & 
            this method is used to subscribe to a user. \\
        \hline unsubscribe() & 
            this method is used to unsubscribe from a user. \\
        \hline
    \end{tabular}
    \caption{Subscription API}
\end{center}
\end{table}

\subsection{Client side}

\subsubsection{Overall design}
The android application is implemented with the following components:
\begin{enumerate}
    \item SignInActivity that handles signing in of users
    \item MainActivity that serve as the hosting activity for different views of the application with a Navigation
        drawer panel to allow users to switch among the views
    \item Google Cloud service that handles the Google Cloud Messaging communication to listen to pushed messages from
        the servers and redirect them to appropriate components
    \item Database services that provides method to access the logic models uses in the class
\end{enumerate}


\subsubsection{Local database}
In order to interact with the local database, all views in the application use centralized point of access. The client application logic
business requires 2 models \texttt{Data} and \texttt{User} and hence there are 2 contract classes that represent the interface to the
database. These interfaces effectively simplify the dependencies and interaction between the views and the models. By having a single mean
of access, it is easier to change the way the data is access globally by changing the interface and also make it easier to debug if
neccessary.

\subsubsection{Services}
The application consists of a set of Service class extending Android's Service that handle interactions with the models and the application
server. The service is invoked from any of the views by creating an Intent with appropriate arguments and the result is then propagated to
all effective views that are interested in the result. Once finishing servicing a request, an event is created and broadcasted to the main
activity. Since there are more and one view that are interested in a given model, the event is received by the main activity and then
propagated to its current view for displaying the result if the view is registered with the activity. Upon creating and replacing a fragment
to the activity, a fragment is registered to receive the broadcasted events following Observer pattern. Each event is implemented with a
pair of Publisher-Listener interfaces with the view implementing the listener interface and the main activity implementing the according
publisher interface.

\paragraph{Subscription Service} \mbox{} \\
Something here

\paragraph{Data Service} \mbox{} \\
Something here

\subsubsection{Graph display}
Displaying of graph is contained in GraphFragment class. This fragment also allows users to choose various ways of
representation of the chart such as which user, time range to display as well as appropriate style of chart for
different types of data. Displaying of the widget is handled by MPAndroidChart by Philipp Jahoda \cite{MPAndroidChart},
provided as a open source library on GitHub under Apache License, Version 2.0. The chart placeholder is populated with a
\texttt{Chart} subsclasses and then appropriate methods are called depending on the choice of representation.

\paragraph{Graph Fragment}
\texttt{GraphFragment} and its subclasses are in charge of create the Chart and inflate it to the layout container.
\texttt{GraphFragment} can be subclassed for specific type of data. In the scope of this project, it is implemented in 2
subclasses namely \texttt{SimpleDataFragment} that uses line chart with 1 entry per each x value and
\texttt{BloodPressureFragment} that uses scatter chart with 2 entries per each x value. The subclasses are required to
implement the abstract methods in \texttt{GraphFragment} to display the data accordingly.  The \texttt{GraphFragment}
contains the following abstract methods that are implemented in the concrete classes:
\begin{lstlisting}
abstract String getDescription();
abstract Cursor getQuery(HealthDroidDatabaseHelper);
abstract Chart makeChart(Context);
abstract DataPool makeDataPool();
\end{lstlisting}
With the appropriate depencies constructed in the concrete classes, an asynchronous task extending from
\texttt{DisplayDataTask} will then be invoked by on the time range selection and inject the dependencies dynamically.

\paragraph{DataPool}
As the graph fragment is required to display data grouped by date differently based on users' choices, the raw data
entries acquired from database querying need to be processed and the accumulated value of a day, week or month is
computed for displaying to the users. To achieve that, every time the task is invoked, all data must be queried and
prepared for processing in a \texttt{DataPool} object. The \texttt{DataPool} object acts as a central repository for
data of all users in the local database to be grouped by their date and then creates a Map containing the grouped
result. The \texttt{DataPool} class contains a mapping between a username and their relevant data entries as well as the
dictionaries mapping date to values. The resulted dictionaries contains appropriate keys generated by a KeyCreator
object for each date range selection e.g. days (05/03/2015) for "by day" choice and month (12/2015) for "by month"
choice.

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline accumulate() & 
            this method start the accumulation of data to create a map from user name to their data set contained in an
            object \texttt{DataAccumulator} \\
        \hline insertToChart() &
            this method takes a \texttt{ChartAdapter} as argument to insert the prepared data from accumulate() into a
            chart \\
        \hline
    \end{tabular}
    \caption{DataPool methods description}
\end{center}
\end{table}

\paragraph{KeyCreator}
The \texttt{KeyCreator} class has the responsibility of creating the values on x-axis as well as the lookup key in the
resulted dictionary. The \texttt{KeyCreator} is declared as an interface and implemented by concrete classes namely
\texttt{ByDayKeyCreator}, \texttt{ByWeekKeyCreator} and \texttt{ByMonthKeyCreator}

%\begin{minipage}{\linewidth}
%\lstset{language=java,caption={KeyCreator interface},label=KeyCreator interface}
%\begin{lstlisting}
%public interface KeyCreator {
%    String createKey(String date);
%    DateRange getDateRange(String firstDate, String lastDate);
%    DateFormat getDateFormat();
%    int getTimeUnit();
%}
%\end{lstlisting}
%\end{minipage}

\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | p{12cm} |}
        \hline Method & Description \\
        \hline createKey() & 
            this method takes a date string in RFC3339 format as parameter and returns the corresponding key string in
            the correct format \\
        \hline getDateRange() &
            this method takes the first date and the last date from the data set i.e. the range of values on x-axis of
            the chart and returns a wrapper object that contains these 2 values and normalize the range to be at least
            10 units. \\
        \hline getTimeUnit() &
            this methods takes no arguments and return the corresponding value from Java Calendar to help get the value
            from GregorianCalendar \\
        \hline
    \end{tabular}
    \caption{KeyCreator methods description}
\end{center}
\end{table}

\paragraph{DataAccumulator}
The \texttt{DataAccumulator} class has the responsiblity of containing a mapping from a string representing a date to a
data representation. Depends on different type of data, the representation is constructed differently. In the scope of
this project, DataAccumulator is extended by 2 concrete classes namely \texttt{SimpleDataAccumulator} that has 1
numerical value per date key and \texttt{BloodPressureDataAccumulator} that has 2 numerical values per date key. The
\texttt{DataAccumulator} exposes the method \texttt{accumulate(String value, String key)} in which value is the String
representation of the data and the concrete class is responsible for deserialize the string to achieve numerical values.

\section{Work done so far}
\label{sec:Work done so far}
\subsection{Server side}

\begin{enumerate}
    \item Implemented a RESTful API for different features on the application including:
    \item Subscribing and Un-subscribing
    \item Posting and Retrieving of Data
    \item Register of new users and devices
    \item Sending Notification messages to users via Google Cloud Messaging
\end{enumerate}

\subsection{Android development practices}
In order to approach the latest change in new Android version and Android SDK, the project aims to use the latest tools
and practices suggested by Google. The client side application was made with consideration about design and components
choices.

\subsection{Software engineering practices}
Different standards in software engineering was considered and followed throughout the development of the application so
that the code can be read and reused by other developers.Serious consideration and effort has been put in the designing
the graph components such that the application can be easily extended to other types of data i.e. blood pressure, blood
sugar etc. as well as different ways of viewing data in the future.

\section{Future work} \label{sec:Work done so far}
Although the core codebase has been completed, there are space for improvement for this project.
\subsection{Features}
\begin{enumerate}
    \item Notifications pushing depending on the data flow to make the application more
        user-friendly
    \item Implementing display view of different types of data
    \item (Optional) Connecting with real measuring devices
        to complete the full-stack solutionImplementation
\end{enumerate}

\subsection{Implementation}
Fixing of remaining bugs in the application

\subsection{Software engineering practices}
Refactor if necessary to have a clean and loosely coupled code base so that it can be reused and integrated with other projects

\section{Conclusion}
In conclusion, the core code base of the project has been completed but there are still features to
be implemented to provide a better interaction with the users.On the other hands, consideration in software engineering
practices and latest change of Android library is also required throughout the process of development for the rest of
the project.

\bibliography{fyp} 
\bibliographystyle{ieeetr}
\end{document}
